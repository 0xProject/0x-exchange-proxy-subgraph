// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class IERC20BridgeSampler__getOrderFillableMakerAssetAmountsInputOrdersStruct extends ethereum.Tuple {
  get makerAddress(): Address {
    return this[0].toAddress();
  }

  get takerAddress(): Address {
    return this[1].toAddress();
  }

  get feeRecipientAddress(): Address {
    return this[2].toAddress();
  }

  get senderAddress(): Address {
    return this[3].toAddress();
  }

  get makerAssetAmount(): BigInt {
    return this[4].toBigInt();
  }

  get takerAssetAmount(): BigInt {
    return this[5].toBigInt();
  }

  get makerFee(): BigInt {
    return this[6].toBigInt();
  }

  get takerFee(): BigInt {
    return this[7].toBigInt();
  }

  get expirationTimeSeconds(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get makerFeeAssetData(): Bytes {
    return this[12].toBytes();
  }

  get takerFeeAssetData(): Bytes {
    return this[13].toBytes();
  }
}

export class IERC20BridgeSampler__getOrderFillableTakerAssetAmountsInputOrdersStruct extends ethereum.Tuple {
  get makerAddress(): Address {
    return this[0].toAddress();
  }

  get takerAddress(): Address {
    return this[1].toAddress();
  }

  get feeRecipientAddress(): Address {
    return this[2].toAddress();
  }

  get senderAddress(): Address {
    return this[3].toAddress();
  }

  get makerAssetAmount(): BigInt {
    return this[4].toBigInt();
  }

  get takerAssetAmount(): BigInt {
    return this[5].toBigInt();
  }

  get makerFee(): BigInt {
    return this[6].toBigInt();
  }

  get takerFee(): BigInt {
    return this[7].toBigInt();
  }

  get expirationTimeSeconds(): BigInt {
    return this[8].toBigInt();
  }

  get salt(): BigInt {
    return this[9].toBigInt();
  }

  get makerAssetData(): Bytes {
    return this[10].toBytes();
  }

  get takerAssetData(): Bytes {
    return this[11].toBytes();
  }

  get makerFeeAssetData(): Bytes {
    return this[12].toBytes();
  }

  get takerFeeAssetData(): Bytes {
    return this[13].toBytes();
  }
}

export class IERC20BridgeSampler__sampleBuysFromKyberNetworkInputOptsStruct extends ethereum.Tuple {
  get targetSlippageBps(): BigInt {
    return this[0].toBigInt();
  }

  get maxIterations(): BigInt {
    return this[1].toBigInt();
  }
}

export class IERC20BridgeSampler__sampleBuysFromLiquidityProviderRegistryInputOptsStruct extends ethereum.Tuple {
  get targetSlippageBps(): BigInt {
    return this[0].toBigInt();
  }

  get maxIterations(): BigInt {
    return this[1].toBigInt();
  }
}

export class IERC20BridgeSampler extends ethereum.SmartContract {
  static bind(address: Address): IERC20BridgeSampler {
    return new IERC20BridgeSampler("IERC20BridgeSampler", address);
  }

  batchCall(callDatas: Array<Bytes>): Array<Bytes> {
    let result = super.call("batchCall", "batchCall(bytes[]):(bytes[])", [
      ethereum.Value.fromBytesArray(callDatas)
    ]);

    return result[0].toBytesArray();
  }

  try_batchCall(callDatas: Array<Bytes>): ethereum.CallResult<Array<Bytes>> {
    let result = super.tryCall("batchCall", "batchCall(bytes[]):(bytes[])", [
      ethereum.Value.fromBytesArray(callDatas)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytesArray());
  }

  getLiquidityProviderFromRegistry(
    registryAddress: Address,
    takerToken: Address,
    makerToken: Address
  ): Address {
    let result = super.call(
      "getLiquidityProviderFromRegistry",
      "getLiquidityProviderFromRegistry(address,address,address):(address)",
      [
        ethereum.Value.fromAddress(registryAddress),
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken)
      ]
    );

    return result[0].toAddress();
  }

  try_getLiquidityProviderFromRegistry(
    registryAddress: Address,
    takerToken: Address,
    makerToken: Address
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getLiquidityProviderFromRegistry",
      "getLiquidityProviderFromRegistry(address,address,address):(address)",
      [
        ethereum.Value.fromAddress(registryAddress),
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getOrderFillableMakerAssetAmounts(
    orders: Array<
      IERC20BridgeSampler__getOrderFillableMakerAssetAmountsInputOrdersStruct
    >,
    orderSignatures: Array<Bytes>
  ): Array<BigInt> {
    let result = super.call(
      "getOrderFillableMakerAssetAmounts",
      "getOrderFillableMakerAssetAmounts(tuple[],bytes[]):(uint256[])",
      [
        ethereum.Value.fromTupleArray(orders),
        ethereum.Value.fromBytesArray(orderSignatures)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_getOrderFillableMakerAssetAmounts(
    orders: Array<
      IERC20BridgeSampler__getOrderFillableMakerAssetAmountsInputOrdersStruct
    >,
    orderSignatures: Array<Bytes>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "getOrderFillableMakerAssetAmounts",
      "getOrderFillableMakerAssetAmounts(tuple[],bytes[]):(uint256[])",
      [
        ethereum.Value.fromTupleArray(orders),
        ethereum.Value.fromBytesArray(orderSignatures)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  getOrderFillableTakerAssetAmounts(
    orders: Array<
      IERC20BridgeSampler__getOrderFillableTakerAssetAmountsInputOrdersStruct
    >,
    orderSignatures: Array<Bytes>
  ): Array<BigInt> {
    let result = super.call(
      "getOrderFillableTakerAssetAmounts",
      "getOrderFillableTakerAssetAmounts(tuple[],bytes[]):(uint256[])",
      [
        ethereum.Value.fromTupleArray(orders),
        ethereum.Value.fromBytesArray(orderSignatures)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_getOrderFillableTakerAssetAmounts(
    orders: Array<
      IERC20BridgeSampler__getOrderFillableTakerAssetAmountsInputOrdersStruct
    >,
    orderSignatures: Array<Bytes>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "getOrderFillableTakerAssetAmounts",
      "getOrderFillableTakerAssetAmounts(tuple[],bytes[]):(uint256[])",
      [
        ethereum.Value.fromTupleArray(orders),
        ethereum.Value.fromBytesArray(orderSignatures)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleBuysFromCurve(
    curveAddress: Address,
    fromTokenIdx: BigInt,
    toTokenIdx: BigInt,
    makerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleBuysFromCurve",
      "sampleBuysFromCurve(address,int128,int128,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(curveAddress),
        ethereum.Value.fromSignedBigInt(fromTokenIdx),
        ethereum.Value.fromSignedBigInt(toTokenIdx),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleBuysFromCurve(
    curveAddress: Address,
    fromTokenIdx: BigInt,
    toTokenIdx: BigInt,
    makerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleBuysFromCurve",
      "sampleBuysFromCurve(address,int128,int128,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(curveAddress),
        ethereum.Value.fromSignedBigInt(fromTokenIdx),
        ethereum.Value.fromSignedBigInt(toTokenIdx),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleBuysFromEth2Dai(
    takerToken: Address,
    makerToken: Address,
    makerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleBuysFromEth2Dai",
      "sampleBuysFromEth2Dai(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleBuysFromEth2Dai(
    takerToken: Address,
    makerToken: Address,
    makerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleBuysFromEth2Dai",
      "sampleBuysFromEth2Dai(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleBuysFromKyberNetwork(
    takerToken: Address,
    makerToken: Address,
    makerTokenAmounts: Array<BigInt>,
    opts: IERC20BridgeSampler__sampleBuysFromKyberNetworkInputOptsStruct
  ): Array<BigInt> {
    let result = super.call(
      "sampleBuysFromKyberNetwork",
      "sampleBuysFromKyberNetwork(address,address,uint256[],(uint256,uint256)):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts),
        ethereum.Value.fromTuple(opts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleBuysFromKyberNetwork(
    takerToken: Address,
    makerToken: Address,
    makerTokenAmounts: Array<BigInt>,
    opts: IERC20BridgeSampler__sampleBuysFromKyberNetworkInputOptsStruct
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleBuysFromKyberNetwork",
      "sampleBuysFromKyberNetwork(address,address,uint256[],(uint256,uint256)):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts),
        ethereum.Value.fromTuple(opts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleBuysFromLiquidityProviderRegistry(
    registryAddress: Address,
    takerToken: Address,
    makerToken: Address,
    makerTokenAmounts: Array<BigInt>,
    opts: IERC20BridgeSampler__sampleBuysFromLiquidityProviderRegistryInputOptsStruct
  ): Array<BigInt> {
    let result = super.call(
      "sampleBuysFromLiquidityProviderRegistry",
      "sampleBuysFromLiquidityProviderRegistry(address,address,address,uint256[],(uint256,uint256)):(uint256[])",
      [
        ethereum.Value.fromAddress(registryAddress),
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts),
        ethereum.Value.fromTuple(opts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleBuysFromLiquidityProviderRegistry(
    registryAddress: Address,
    takerToken: Address,
    makerToken: Address,
    makerTokenAmounts: Array<BigInt>,
    opts: IERC20BridgeSampler__sampleBuysFromLiquidityProviderRegistryInputOptsStruct
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleBuysFromLiquidityProviderRegistry",
      "sampleBuysFromLiquidityProviderRegistry(address,address,address,uint256[],(uint256,uint256)):(uint256[])",
      [
        ethereum.Value.fromAddress(registryAddress),
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts),
        ethereum.Value.fromTuple(opts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleBuysFromUniswap(
    takerToken: Address,
    makerToken: Address,
    makerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleBuysFromUniswap",
      "sampleBuysFromUniswap(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleBuysFromUniswap(
    takerToken: Address,
    makerToken: Address,
    makerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleBuysFromUniswap",
      "sampleBuysFromUniswap(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleBuysFromUniswapV2(
    path: Array<Address>,
    makerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleBuysFromUniswapV2",
      "sampleBuysFromUniswapV2(address[],uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(path),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleBuysFromUniswapV2(
    path: Array<Address>,
    makerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleBuysFromUniswapV2",
      "sampleBuysFromUniswapV2(address[],uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(path),
        ethereum.Value.fromUnsignedBigIntArray(makerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleSellsFromCurve(
    curveAddress: Address,
    fromTokenIdx: BigInt,
    toTokenIdx: BigInt,
    takerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleSellsFromCurve",
      "sampleSellsFromCurve(address,int128,int128,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(curveAddress),
        ethereum.Value.fromSignedBigInt(fromTokenIdx),
        ethereum.Value.fromSignedBigInt(toTokenIdx),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleSellsFromCurve(
    curveAddress: Address,
    fromTokenIdx: BigInt,
    toTokenIdx: BigInt,
    takerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleSellsFromCurve",
      "sampleSellsFromCurve(address,int128,int128,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(curveAddress),
        ethereum.Value.fromSignedBigInt(fromTokenIdx),
        ethereum.Value.fromSignedBigInt(toTokenIdx),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleSellsFromEth2Dai(
    takerToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleSellsFromEth2Dai",
      "sampleSellsFromEth2Dai(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleSellsFromEth2Dai(
    takerToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleSellsFromEth2Dai",
      "sampleSellsFromEth2Dai(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleSellsFromKyberNetwork(
    takerToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleSellsFromKyberNetwork",
      "sampleSellsFromKyberNetwork(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleSellsFromKyberNetwork(
    takerToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleSellsFromKyberNetwork",
      "sampleSellsFromKyberNetwork(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleSellsFromLiquidityProviderRegistry(
    registryAddress: Address,
    takerToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleSellsFromLiquidityProviderRegistry",
      "sampleSellsFromLiquidityProviderRegistry(address,address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(registryAddress),
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleSellsFromLiquidityProviderRegistry(
    registryAddress: Address,
    takerToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleSellsFromLiquidityProviderRegistry",
      "sampleSellsFromLiquidityProviderRegistry(address,address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(registryAddress),
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleSellsFromMultiBridge(
    multibridge: Address,
    takerToken: Address,
    intermediateToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleSellsFromMultiBridge",
      "sampleSellsFromMultiBridge(address,address,address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(multibridge),
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(intermediateToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleSellsFromMultiBridge(
    multibridge: Address,
    takerToken: Address,
    intermediateToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleSellsFromMultiBridge",
      "sampleSellsFromMultiBridge(address,address,address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(multibridge),
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(intermediateToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleSellsFromUniswap(
    takerToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleSellsFromUniswap",
      "sampleSellsFromUniswap(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleSellsFromUniswap(
    takerToken: Address,
    makerToken: Address,
    takerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleSellsFromUniswap",
      "sampleSellsFromUniswap(address,address,uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddress(takerToken),
        ethereum.Value.fromAddress(makerToken),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  sampleSellsFromUniswapV2(
    path: Array<Address>,
    takerTokenAmounts: Array<BigInt>
  ): Array<BigInt> {
    let result = super.call(
      "sampleSellsFromUniswapV2",
      "sampleSellsFromUniswapV2(address[],uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(path),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_sampleSellsFromUniswapV2(
    path: Array<Address>,
    takerTokenAmounts: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "sampleSellsFromUniswapV2",
      "sampleSellsFromUniswapV2(address[],uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(path),
        ethereum.Value.fromUnsignedBigIntArray(takerTokenAmounts)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }
}
